prob.sum<-sum(exp(aa))
result.prob<-(exp(aa))/prob.sum
}else{
result.prob=PIP.func(result.B.list[[1]],result.B.list[[2]],p)
}
conditional.S.list<-data.frame(Index=conditional.S,Z=z[conditional.S])
rb1=result.B.list[[1]]
difference<-abs(mean(rb1[1:round(length(rb1)/4)])-stored.bf)
print(difference)
if(difference<epsilon){
break
}else{
stored.bf<-mean(rb1[1:round(length(rb1)/4)])
}
}
for(l in 1:inner.all.iter){
for(h in 1:10){
##############Shotgun COMPUTATION ############
set.gamma<-set.gamma.func(S,conditional.S,p)
if(is.null(conditional.S)){
working.S=S
}else{
working.S=S[-match(conditional.S,S)]
}
set.gamma.margin<-list()
set.gamma.prior<-list()
matrix.gamma<-list()
if(length(working.S)!=0){
S.model<-as(Matrix(nrow=1,ncol=p,sparse = T,data=0),'CsparseMatrix')
S.model[,working.S]<-1
p_S=length(working.S)
current.log.margin<-marginal_likelihood(working.S,Sigma,z,tau=tau.sample,p_S=p_S,y.var)+prior.dist(S.model)
}else{
current.log.margin<-prior.dist(null.model)
}
for(i in  1:length(set.gamma)){
if (length(set.gamma[[i]])>0){
matrix.gamma[[i]]<-index.fun(set.gamma[[i]],p=p)
p_S=dim(set.gamma[[i]])[2]
set.gamma.margin[[i]]<-apply(set.gamma[[i]],1,marginal_likelihood,Sigma=Sigma,z=z,tau=tau.sample,p_S=p_S,y_sigma=y.var)
set.gamma.prior[[i]]<-apply(matrix.gamma[[i]],1,prior.dist)
set.gamma.margin[[i]]=set.gamma.prior[[i]]+set.gamma.margin[[i]]
} else {
set.gamma.margin[[i]]=null.margin
set.gamma.prior[[i]]=NULL
matrix.gamma[[i]]=null.model
}
}
add.B<-list()
add.B[[1]]<-NULL
add.B[[2]]<-as(Matrix(nrow=0,ncol=p,sparse = T,data=0),'CsparseMatrix')
for(i in 1:length(set.gamma)){
if (!is.null(set.gamma.margin[[i]])){
add.B[[1]]<-c(add.B[[1]],set.gamma.margin[[i]])
add.B[[2]]<-rbind(add.B[[2]],matrix.gamma[[i]])
}
}
########## add visited models into the storage space of models###############
add.index<-match.dgCMatrix(B.list[[2]],add.B[[2]])
if(length(na.omit(add.index))!=0){
B.list[[1]]<-c((B.list[[1]]),(add.B[[1]][is.na(add.index)]))
B.list[[2]]<-rbind(B.list[[2]],add.B[[2]][is.na(add.index),,drop=F])
}else{
B.list[[1]]<-c((B.list[[1]]),(add.B[[1]]))
B.list[[2]]<-rbind(B.list[[2]],add.B[[2]])
}
B.list[[2]]<-B.list[[2]][order(B.list[[1]],decreasing = T),]
B.list[[1]]<-B.list[[1]][order(B.list[[1]],decreasing = T)]
###################Select next visiting model###############
if(length(working.S)!=0){
set.star<-data.frame(set.index=1:3,gamma.set.index=rep(NA,3),margin=rep(NA,3))
for(i in 1:3){
aa<-set.gamma.margin[[i]]-current.log.margin
aa<-aa-aa[which.max(aa)]
if(length(which(is.nan(aa)))!=0){
aa[which(is.nan(aa))]<-min(aa)
}
set.star$gamma.set.index[i] <-sample(1:length(set.gamma.margin[[i]]),1,prob=exp(aa))
set.star$margin[i]<-set.gamma.margin[[i]][set.star$gamma.set.index[i]]
}
#######The Bayesian hypothesis testing for Z-scores/LD discrepancies########
if(outlier.switch){
for(i in 2:length(set.gamma)){
repeat{
aa<-set.gamma.margin[[i]]-current.log.margin
aa<-aa-aa[which.max(aa)]
if(length(which(is.nan(aa)))!=0){
aa[which(is.nan(aa))]<-min(aa[!is.na(aa)])
}
set.star$gamma.set.index[i]<-c(sample((1:length(set.gamma.margin[[i]])),
1,prob=exp(aa)))
set.star$margin[i]<-set.gamma.margin[[i]][  set.star$gamma.set.index[i]]
test.S<-set.gamma[[i]][set.star$gamma.set.index[i],]
modi.Sigma=temp.Sigma=Sigma
if(length(test.S)>1){
modi.ld.S<- modi.Sigma[test.S,test.S]
opizer<-optimize(ridge.fun,interval=c(0,1),maximum = T)
modi.ld.S<-opizer$maximum*modi.ld.S+(1-opizer$maximum)*diag(nrow(modi.ld.S))
modi.Sigma[test.S,test.S]<-modi.ld.S
test.log.BF<-outlier_likelihood(test.S,Sigma,z,outlier.tau,length(test.S),1)-outlier_likelihood(test.S,modi.Sigma,z,outlier.tau,length(test.S),1)
test.log.BF<--abs(test.log.BF)
print(paste0('Outlier BF: ', test.log.BF))
print(test.S)
print(paste0('This is xi hat: ', opizer))
}
if(exp(test.log.BF)<outlier.BF.index){
set.gamma[[i]]<-set.gamma[[i]][-set.star$gamma.set.index[i],]
set.gamma.margin[[i]]<-set.gamma.margin[[i]][-set.star$gamma.set.index[i]]
conditional.S<-c(conditional.S,setdiff(test.S,working.S))
conditional.S<-unique(conditional.S)
}else{
break
}
}
}
}
print(set.star)
if(length(working.S)==num.causal){
set.star<-set.star[-2,]
aa<-set.star$margin-current.log.margin-max(set.star$margin-current.log.margin)
sec.sample<-sample(c(1,3),1,prob=exp(aa))
S<-set.gamma[[sec.sample]][set.star$gamma.set.index[[which(sec.sample==set.star$set.index)]] ,]
}else{
aa<-set.star$margin-current.log.margin-max(set.star$margin-current.log.margin)
sec.sample<-sample(1:3,1,prob=exp(aa) )
S<-set.gamma[[sec.sample]][set.star$gamma.set.index[[sec.sample]] ,]
}
}else{
set.star<-data.frame(set.index=rep(1,3),gamma.set.index=rep(NA,3),margin=rep(NA,3))
aa<-set.gamma.margin[[2]]-current.log.margin
aa<-aa-aa[which.max(aa)]
if(length(which(is.nan(aa)))!=0){
aa[which(is.nan(aa))]<-min(aa)
}
set.star$gamma.set.index[2] <-c(sample((1:length(set.gamma.margin[[2]]))[order(exp(aa),decreasing = T)[1:(min(length(aa),floor(p/2)))]],
1,prob=exp(aa)[order(exp(aa),decreasing = T)[1:(min(length(aa),floor(p/2)))]]))
set.star$margin[2]<-set.gamma.margin[[2]][  set.star$gamma.set.index[2]]
S<-set.gamma[[2]][set.star$gamma.set.index[2],]
print(set.star)
}
print(paste0('this is running S: ',paste0(S,collapse = ',')))
S<-unique(c(S,conditional.S))
}
######Output of the results of the module function######
if(!is.null(conditional.S)){
all.c.index<-c()
for(tt in conditional.S){
c.index<-(B.list[[2]]@i[min(length(B.list[[2]]@i),(B.list[[2]]@p[tt]+1)):B.list[[2]]@p[tt+1]])+1
all.c.index<-c(all.c.index,c.index)
}
all.c.index<-unique(all.c.index)
temp.B.list<-list()
temp.B.list[[1]]<-B.list[[1]][-all.c.index]
temp.B.list[[2]]<-B.list[[2]][-all.c.index,]
}else{
temp.B.list<-list()
temp.B.list[[1]]<-B.list[[1]]
temp.B.list[[2]]<-B.list[[2]]
}
result.B.list<-list()
result.B.list[[1]]<-temp.B.list[[1]][(1:min(B,nrow(temp.B.list[[2]])))]
result.B.list[[2]]<-temp.B.list[[2]][(1:min(B,nrow(temp.B.list[[2]]))),]
if(num.causal==1){
single.set<-matrix(1:p,p,1)
single.marginal<-apply(single.set,1,marginal_likelihood,Sigma=Sigma,z=z,tau=tau.sample,p_S=1,y_sigma=y.var)
aa<-single.marginal-max(single.marginal,na.rm=T)
prob.sum<-sum(exp(aa))
result.prob<-(exp(aa))/prob.sum
}else{
result.prob=PIP.func(result.B.list[[1]],result.B.list[[2]],p)
}
conditional.S.list<-data.frame(Index=conditional.S,Z=z[conditional.S])
rb1=result.B.list[[1]]
difference<-abs(mean(rb1[1:round(length(rb1)/4)])-stored.bf)
print(difference)
if(difference<epsilon){
break
}else{
stored.bf<-mean(rb1[1:round(length(rb1)/4)])
}
}
for(l in 1:inner.all.iter){
for(h in 1:10){
##############Shotgun COMPUTATION ############
set.gamma<-set.gamma.func(S,conditional.S,p)
if(is.null(conditional.S)){
working.S=S
}else{
working.S=S[-match(conditional.S,S)]
}
set.gamma.margin<-list()
set.gamma.prior<-list()
matrix.gamma<-list()
if(length(working.S)!=0){
S.model<-as(Matrix(nrow=1,ncol=p,sparse = T,data=0),'CsparseMatrix')
S.model[,working.S]<-1
p_S=length(working.S)
current.log.margin<-marginal_likelihood(working.S,Sigma,z,tau=tau.sample,p_S=p_S,y.var)+prior.dist(S.model)
}else{
current.log.margin<-prior.dist(null.model)
}
for(i in  1:length(set.gamma)){
if (length(set.gamma[[i]])>0){
matrix.gamma[[i]]<-index.fun(set.gamma[[i]],p=p)
p_S=dim(set.gamma[[i]])[2]
set.gamma.margin[[i]]<-apply(set.gamma[[i]],1,marginal_likelihood,Sigma=Sigma,z=z,tau=tau.sample,p_S=p_S,y_sigma=y.var)
set.gamma.prior[[i]]<-apply(matrix.gamma[[i]],1,prior.dist)
set.gamma.margin[[i]]=set.gamma.prior[[i]]+set.gamma.margin[[i]]
} else {
set.gamma.margin[[i]]=null.margin
set.gamma.prior[[i]]=NULL
matrix.gamma[[i]]=null.model
}
}
add.B<-list()
add.B[[1]]<-NULL
add.B[[2]]<-as(Matrix(nrow=0,ncol=p,sparse = T,data=0),'CsparseMatrix')
for(i in 1:length(set.gamma)){
if (!is.null(set.gamma.margin[[i]])){
add.B[[1]]<-c(add.B[[1]],set.gamma.margin[[i]])
add.B[[2]]<-rbind(add.B[[2]],matrix.gamma[[i]])
}
}
########## add visited models into the storage space of models###############
add.index<-match.dgCMatrix(B.list[[2]],add.B[[2]])
if(length(na.omit(add.index))!=0){
B.list[[1]]<-c((B.list[[1]]),(add.B[[1]][is.na(add.index)]))
B.list[[2]]<-rbind(B.list[[2]],add.B[[2]][is.na(add.index),,drop=F])
}else{
B.list[[1]]<-c((B.list[[1]]),(add.B[[1]]))
B.list[[2]]<-rbind(B.list[[2]],add.B[[2]])
}
B.list[[2]]<-B.list[[2]][order(B.list[[1]],decreasing = T),]
B.list[[1]]<-B.list[[1]][order(B.list[[1]],decreasing = T)]
###################Select next visiting model###############
if(length(working.S)!=0){
set.star<-data.frame(set.index=1:3,gamma.set.index=rep(NA,3),margin=rep(NA,3))
for(i in 1:3){
aa<-set.gamma.margin[[i]]-current.log.margin
aa<-aa-aa[which.max(aa)]
if(length(which(is.nan(aa)))!=0){
aa[which(is.nan(aa))]<-min(aa)
}
set.star$gamma.set.index[i] <-sample(1:length(set.gamma.margin[[i]]),1,prob=exp(aa))
set.star$margin[i]<-set.gamma.margin[[i]][set.star$gamma.set.index[i]]
}
#######The Bayesian hypothesis testing for Z-scores/LD discrepancies########
if(outlier.switch){
for(i in 2:length(set.gamma)){
repeat{
aa<-set.gamma.margin[[i]]-current.log.margin
aa<-aa-aa[which.max(aa)]
if(length(which(is.nan(aa)))!=0){
aa[which(is.nan(aa))]<-min(aa[!is.na(aa)])
}
set.star$gamma.set.index[i]<-c(sample((1:length(set.gamma.margin[[i]])),
1,prob=exp(aa)))
set.star$margin[i]<-set.gamma.margin[[i]][  set.star$gamma.set.index[i]]
test.S<-set.gamma[[i]][set.star$gamma.set.index[i],]
modi.Sigma=temp.Sigma=Sigma
if(length(test.S)>1){
modi.ld.S<- modi.Sigma[test.S,test.S]
opizer<-optimize(ridge.fun,interval=c(0,1),maximum = T)
modi.ld.S<-opizer$maximum*modi.ld.S+(1-opizer$maximum)*diag(nrow(modi.ld.S))
modi.Sigma[test.S,test.S]<-modi.ld.S
test.log.BF<-outlier_likelihood(test.S,Sigma,z,outlier.tau,length(test.S),1)-outlier_likelihood(test.S,modi.Sigma,z,outlier.tau,length(test.S),1)
test.log.BF<--abs(test.log.BF)
}
if(exp(test.log.BF)<outlier.BF.index){
set.gamma[[i]]<-set.gamma[[i]][-set.star$gamma.set.index[i],]
set.gamma.margin[[i]]<-set.gamma.margin[[i]][-set.star$gamma.set.index[i]]
conditional.S<-c(conditional.S,setdiff(test.S,working.S))
conditional.S<-unique(conditional.S)
}else{
break
}
}
}
}
if(length(working.S)==num.causal){
set.star<-set.star[-2,]
aa<-set.star$margin-current.log.margin-max(set.star$margin-current.log.margin)
sec.sample<-sample(c(1,3),1,prob=exp(aa))
S<-set.gamma[[sec.sample]][set.star$gamma.set.index[[which(sec.sample==set.star$set.index)]] ,]
}else{
aa<-set.star$margin-current.log.margin-max(set.star$margin-current.log.margin)
sec.sample<-sample(1:3,1,prob=exp(aa) )
S<-set.gamma[[sec.sample]][set.star$gamma.set.index[[sec.sample]] ,]
}
}else{
set.star<-data.frame(set.index=rep(1,3),gamma.set.index=rep(NA,3),margin=rep(NA,3))
aa<-set.gamma.margin[[2]]-current.log.margin
aa<-aa-aa[which.max(aa)]
if(length(which(is.nan(aa)))!=0){
aa[which(is.nan(aa))]<-min(aa)
}
set.star$gamma.set.index[2] <-c(sample((1:length(set.gamma.margin[[2]]))[order(exp(aa),decreasing = T)[1:(min(length(aa),floor(p/2)))]],
1,prob=exp(aa)[order(exp(aa),decreasing = T)[1:(min(length(aa),floor(p/2)))]]))
set.star$margin[2]<-set.gamma.margin[[2]][  set.star$gamma.set.index[2]]
S<-set.gamma[[2]][set.star$gamma.set.index[2],]
}
S<-unique(c(S,conditional.S))
}
######Output of the results of the module function######
if(!is.null(conditional.S)){
all.c.index<-c()
for(tt in conditional.S){
c.index<-(B.list[[2]]@i[min(length(B.list[[2]]@i),(B.list[[2]]@p[tt]+1)):B.list[[2]]@p[tt+1]])+1
all.c.index<-c(all.c.index,c.index)
}
all.c.index<-unique(all.c.index)
temp.B.list<-list()
temp.B.list[[1]]<-B.list[[1]][-all.c.index]
temp.B.list[[2]]<-B.list[[2]][-all.c.index,]
}else{
temp.B.list<-list()
temp.B.list[[1]]<-B.list[[1]]
temp.B.list[[2]]<-B.list[[2]]
}
result.B.list<-list()
result.B.list[[1]]<-temp.B.list[[1]][(1:min(B,nrow(temp.B.list[[2]])))]
result.B.list[[2]]<-temp.B.list[[2]][(1:min(B,nrow(temp.B.list[[2]]))),]
if(num.causal==1){
single.set<-matrix(1:p,p,1)
single.marginal<-apply(single.set,1,marginal_likelihood,Sigma=Sigma,z=z,tau=tau.sample,p_S=1,y_sigma=y.var)
aa<-single.marginal-max(single.marginal,na.rm=T)
prob.sum<-sum(exp(aa))
result.prob<-(exp(aa))/prob.sum
}else{
result.prob=PIP.func(result.B.list[[1]],result.B.list[[2]],p)
}
conditional.S.list<-data.frame(Index=conditional.S,Z=z[conditional.S])
rb1=result.B.list[[1]]
difference<-abs(mean(rb1[1:round(length(rb1)/4)])-stored.bf)
print(difference)
if(difference<epsilon){
break
}else{
stored.bf<-mean(rb1[1:round(length(rb1)/4)])
}
}
source("new_MCS_fun.R")
all.C.list<-MCS_modified(z,ld,epsilon=epsilon.list,
Max.Model.Dim=Max.Model.Dim,lambda = 1,
outlier.switch=outlier.switch,tau=tau,
num.causal = num.causal,y.var=y.var,
label = "l",output.labels = output.labels,
effect.size.prior=effect.size.prior,
inner.all.iter = all.inner.iter)
source("new_MCS_fun.R")
all.C.list<-MCS_modified(z,ld,epsilon=epsilon.list,
Max.Model.Dim=Max.Model.Dim,lambda = 1,
outlier.switch=outlier.switch,tau=tau,
num.causal = num.causal,y.var=y.var,
label = "l",output.labels = output.labels,
effect.size.prior=effect.size.prior,
inner.all.iter = all.inner.iter)
t1=Sys.time()-t0
print(paste0('This is locus burning time'))
print((t1))
########Running CARMA########
for(g in 1:all.iter){
delete.list<-integer(0)
if(outlier.switch & (nrow(all.C.list[[4]])!=0)){
delete.list<-all.C.list[[4]]$Index
}
ac1=all.C.list[[1]][[1]]
previous.result<-mean(ac1[1:round(length(ac1)/4)])
prior.prob.list<-list(NULL)
#######Fine-mapping step for each locus, i.e., the E-step in the EM algorithm
t0=Sys.time()
#  all.C.list<-Module.Cauchy.Shotgun(z=z,ld,input.conditional.S.list = all.C.list[[4]],
#                                    y.var=y.var,num.causal = num.causal,epsilon=epsilon.list,
#                                    Max.Model.Dim=Max.Model.Dim,
#                                    C.list = all.C.list[[2]],
#                                    outlier.switch=outlier.switch,tau=tau,
#                                    lambda = 1, label = "l",output.labels = output.labels,
#                                    effect.size.prior=effect.size.prior,inner.all.iter = all.inner.iter)
all.C.list<-MCS_modified(z=z,ld,input.conditional.S.list = all.C.list[[4]],
Max.Model.Dim=Max.Model.Dim,
y.var=y.var,num.causal = num.causal,epsilon=epsilon.list,
outlier.switch=outlier.switch,tau=tau,
lambda = 1, label = "l",output.labels = output.labels,
effect.size.prior=effect.size.prior,inner.all.iter = all.inner.iter)
t1=Sys.time()-t0
print(paste0('This is locus computing time'))
print((t1))
ac1=all.C.list[[1]][[1]]
difference<-abs(previous.result-mean(ac1[1:round(length(ac1)/4)]))
print(paste0('This is difference; ',difference))
if(difference<all.epsilon.threshold){
break
}
}
results.list<-list()
pip=all.C.list[[3]]
credible.set<-credible.set.fun.improved(pip,ld,rho=rho.index)
credible.model<-credible.model.fun(all.C.list[[1]][[1]],all.C.list[[1]][[2]],bayes.threshold = BF.index)
results.list[[1]]<-pip
results.list[[2]]<-credible.set
results.list[[3]]<-credible.model
results.list[[4]]<-all.C.list[[4]]
results.list[[5]]<-all.C.list
names(results.list)<-c('PIPs','Credible_set','Credible_model','Outliers','all.C.list')
results.list[[1]]
results.list[[4]]
setwd("~/Projects/Sanger_OT_CARMA_refactor/01_test/")
load("test.RData")
library(CARMA)
library(Matrix)
source("CARMA_miscs.R")
#ASSUMPTIONS
w.list=NULL
effect.size.prior='Spike-slab'
EM.dist='Logistic'
prior.prob.computation='Logistic'
label.list=NULL
#Init of variables
output.labels='.'
rho.index=0.99
setwd("~/Projects/Sanger_OT_CARMA_refactor/01_test/")
load("test.RData")
library(CARMA)
library(Matrix)
source("CARMA_miscs.R")
#ASSUMPTIONS
w.list=NULL
effect.size.prior='Spike-slab'
EM.dist='Logistic'
prior.prob.computation='Logistic'
label.list=NULL
#Init of variables
output.labels='.'
rho.index=0.99
BF.index=10
Max.Model.Dim=2e+5
all.iter=3
all.inner.iter=10
input.alpha=0
epsilon.threshold=1e-5
printing.log=F
num.causal=10
y.var=1
tau=0.04
outlier.switch=T
outlier.BF.index=1/3.2
model.prior='Poisson'
###input
z=z.list[[2]]
p_snp=length(z)
ld=ld.list[[2]]
epsilon.list<-epsilon.threshold*p_snp
all.epsilon.threshold<-epsilon.threshold*p_snp
########Run fine-mapping step (module function) for each locus included in the analysis
t0=Sys.time()
source("new_MCS_fun.R")
all.C.list<-MCS_modified(z,ld,epsilon=epsilon.list,
Max.Model.Dim=Max.Model.Dim,lambda = 1,
outlier.switch=outlier.switch,tau=tau,
num.causal = num.causal,y.var=y.var,
label = "l",output.labels = output.labels,
effect.size.prior=effect.size.prior,
inner.all.iter = all.inner.iter)
t1=Sys.time()-t0
print(paste0('This is locus burning time'))
print((t1))
########Running CARMA########
for(g in 1:all.iter){
delete.list<-integer(0)
if(outlier.switch & (nrow(all.C.list[[4]])!=0)){
delete.list<-all.C.list[[4]]$Index
}
ac1=all.C.list[[1]][[1]]
previous.result<-mean(ac1[1:round(length(ac1)/4)])
prior.prob.list<-list(NULL)
#######Fine-mapping step for each locus, i.e., the E-step in the EM algorithm
t0=Sys.time()
#  all.C.list<-Module.Cauchy.Shotgun(z=z,ld,input.conditional.S.list = all.C.list[[4]],
#                                    y.var=y.var,num.causal = num.causal,epsilon=epsilon.list,
#                                    Max.Model.Dim=Max.Model.Dim,
#                                    C.list = all.C.list[[2]],
#                                    outlier.switch=outlier.switch,tau=tau,
#                                    lambda = 1, label = "l",output.labels = output.labels,
#                                    effect.size.prior=effect.size.prior,inner.all.iter = all.inner.iter)
all.C.list<-MCS_modified(z=z,ld,input.conditional.S.list = all.C.list[[4]],
Max.Model.Dim=Max.Model.Dim,
y.var=y.var,num.causal = num.causal,epsilon=epsilon.list,
outlier.switch=outlier.switch,tau=tau,
lambda = 1, label = "l",output.labels = output.labels,
effect.size.prior=effect.size.prior,inner.all.iter = all.inner.iter)
t1=Sys.time()-t0
print(paste0('This is locus computing time'))
print((t1))
ac1=all.C.list[[1]][[1]]
difference<-abs(previous.result-mean(ac1[1:round(length(ac1)/4)]))
print(paste0('This is difference; ',difference))
if(difference<all.epsilon.threshold){
break
}
}
results.list<-list()
pip=all.C.list[[3]]
credible.set<-credible.set.fun.improved(pip,ld,rho=rho.index)
credible.model<-credible.model.fun(all.C.list[[1]][[1]],all.C.list[[1]][[2]],bayes.threshold = BF.index)
results.list[[1]]<-pip
results.list[[2]]<-credible.set
results.list[[3]]<-credible.model
results.list[[4]]<-all.C.list[[4]]
results.list[[5]]<-all.C.list
names(results.list)<-c('PIPs','Credible_set','Credible_model','Outliers','all.C.list')
results.list[[1]]
results.list[[4]]
